        -:    0:Source:../src/circular-buffer.c
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Copyright (c) 2008  Weston Schmidt
        -:    3: *
        -:    4: * This library is free software; you can redistribute it and/or
        -:    5: * modify it under the terms of the GNU Lesser General Public
        -:    6: * License as published by the Free Software Foundation; either
        -:    7: * version 2.1 of the License, or (at your option) any later version.
        -:    8: *
        -:    9: * This library is distributed in the hope that it will be useful,
        -:   10: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   12: * Lesser General Public License for more details.
        -:   13: *
        -:   14: * You should have received a copy of the GNU Lesser General Public
        -:   15: * License along with this library; if not, write to the Free Software
        -:   16: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
        -:   17: *
        -:   18: * In other words, you are welcome to use, share and improve this program.
        -:   19: * You are forbidden to forbid anyone else to use, share and improve
        -:   20: * what you give them.   Help stamp out software-hoarding!
        -:   21: */
        -:   22:
        -:   23:#include "circular-buffer.h"
        -:   24:
        -:   25:#include <stdlib.h>
        -:   26:#include <string.h>
        -:   27:
        -:   28:typedef struct {
        -:   29:    void * head;
        -:   30:    void * tail;
        -:   31:    size_t element_number;
        -:   32:    size_t element_size;
        -:   33:    void * data;
        -:   34:} cb_struct_t;
        -:   35:
function cb_create_list called 4 returned 100% blocks executed 100%
        4:   36:void *cb_create_list( size_t size, uint8_t num )
        -:   37:{
        -:   38:    void *ptr;
        4:   39:    if(    ( 0 == size )
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:   40:        || ( 0 == num ) ) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        2:   41:        return NULL;
        -:   42:    }
        2:   43:    ptr = malloc( sizeof(cb_struct_t) + (size * num) );
        2:   44:    ((cb_struct_t *)ptr)->element_number = num;
        2:   45:    ((cb_struct_t *)ptr)->element_size = size;
        2:   46:    ((cb_struct_t *)ptr)->data = ptr + sizeof(cb_struct_t);
        2:   47:    cb_clear_list(ptr);
call    0 returned 2
        -:   48:
        2:   49:    return ptr;
        -:   50:}
        -:   51:
function cb_clear_list called 4 returned 100% blocks executed 100%
        4:   52:void cb_clear_list( void * list )
        -:   53:{
        4:   54:    cb_struct_t *ptr = (cb_struct_t*)list;
        4:   55:    size_t num = ptr->element_number;
        4:   56:    size_t element_size = ptr->element_size;
        4:   57:    bzero(ptr->data, num*element_size);
        4:   58:    ptr->head = NULL;
        4:   59:    ptr->tail = NULL;
        4:   60:}
        -:   61:
function cb_destroy_list called 2 returned 100% blocks executed 100%
        2:   62:void cb_destroy_list( void ** list )
        -:   63:{
        2:   64:    if(    ( NULL != list )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:   65:        && ( NULL != *list ) ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:   66:        free( *list );
        2:   67:        *list = NULL;
        -:   68:    }
        2:   69:}
        -:   70:
function cb_peek_tail called 2 returned 100% blocks executed 100%
        2:   71:void *cb_peek_tail( void * list )
        -:   72:{
        2:   73:    return ((cb_struct_t*)list)->tail;
        -:   74:}
        -:   75:
function __move_ptr_next_element called 12 returned 100% blocks executed 100%
       12:   76:void __move_ptr_next_element( void ** ptr, void *data_start, size_t element_size, size_t element_num )
        -:   77:{
       12:   78:    void * calc = data_start + (element_size * (element_num-1));
       12:   79:    *ptr += element_size;
       12:   80:    if( *ptr > calc ) {
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        1:   81:        *ptr -= element_size * element_num;
        -:   82:    }
       12:   83:}
        -:   84:
function __move_ptr_prev_element called 8 returned 100% blocks executed 100%
        8:   85:void __move_ptr_prev_element( void ** ptr, void *data_start, size_t element_size, size_t element_num )
        -:   86:{
        8:   87:    *ptr -= element_size;
        8:   88:    if( *ptr < data_start ) {
branch  0 taken 1 (fallthrough)
branch  1 taken 7
        1:   89:        *ptr += element_num * element_size;
        -:   90:    }
        8:   91:}
        -:   92:
function cb_pop called 12 returned 100% blocks executed 100%
       12:   93:bool cb_pop( void * list, void *item )
        -:   94:{
       12:   95:    cb_struct_t * cb_list = (cb_struct_t*)list;
       12:   96:    if(    ( NULL == list )
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12:   97:        || ( NULL == item )
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12:   98:        || ( NULL == cb_list->head ) ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 10
        2:   99:        return false;
        -:  100:    }
       10:  101:    memcpy(item, cb_list->tail, cb_list->element_size);
        -:  102:
       10:  103:    if( cb_list->head == cb_list->tail ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 8
        2:  104:        cb_clear_list(list);
call    0 returned 2
        -:  105:    } else {
        8:  106:        __move_ptr_prev_element(&cb_list->tail,
call    0 returned 8
        -:  107:                cb_list->data,
        -:  108:                cb_list->element_size,
        -:  109:                cb_list->element_number);
        -:  110:    }
        -:  111:
       10:  112:    return true;
        -:  113:}
        -:  114:
function cb_push called 14 returned 100% blocks executed 100%
       14:  115:bool cb_push( void * list, void * element )
        -:  116:{
       14:  117:    cb_struct_t * cb_list = (cb_struct_t*)list;
       14:  118:    if(    ( NULL == list )
branch  0 taken 13 (fallthrough)
branch  1 taken 1
       13:  119:        || ( NULL == element ) ) {
branch  0 taken 1 (fallthrough)
branch  1 taken 12
        2:  120:        return false;
        -:  121:    }
        -:  122:
       12:  123:    if( NULL == cb_list->tail ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 10
        2:  124:        cb_list->head = cb_list->data;
        2:  125:        cb_list->tail = cb_list->head;
        -:  126:    } else {
       10:  127:        __move_ptr_next_element(&cb_list->tail,
call    0 returned 10
        -:  128:                cb_list->data,
        -:  129:                cb_list->element_size,
        -:  130:                cb_list->element_number);
       10:  131:        if( cb_list->head == cb_list->tail ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 8
        2:  132:            __move_ptr_next_element(&cb_list->head,
call    0 returned 2
        -:  133:                    cb_list->data,
        -:  134:                    cb_list->element_size,
        -:  135:                    cb_list->element_number);
        -:  136:        }
        -:  137:    }
       12:  138:    memcpy( cb_list->tail, element, cb_list->element_size );
       12:  139:    return true;
        -:  140:}
